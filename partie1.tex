\section{Présentation du projet}

\subsection{Position du problème}

Le domaine des \textbf{assistants de preuve} automatiques ou interactifs fait encore l'objet de nombreux sujets de recherche aujourd'hui. Bien que ce champ de recherche soit encore très actif, on peut considérer qu'il arrive à maturité. Les assistants de preuve se développent, à l'instar de Coq qui inclut de plus en plus de tactiques allant vers une automatisation croissante ; leur utilisation se répand et aide à la formalisation de grands théorèmes, comme le théorème des quatre couleurs ou le théorème de Feit et Thompson ; ils s'étendent à d'autres domaines comme la vérification de logiciels et de modèles hybrides, à d'autres logiques comme la Logique Temporelle Linéaire.\\

Malgré ces travaux, les interfaces utilisateurs pour assistants de preuve ont, dans la plupart des cas, constitué un ajout après coup, et les réflexions sur le sujet sont encore embryonnaires. On peut d'ailleurs observer le paysage des assistants de preuve aujourd'hui pour constater la disparité des interfaces utilisateurs et l'absence de cohérence entre elles.\\

Certains logiciels sont tout simplement dépourvus d'interface utilisateur ou offrent une interaction minimale en ligne de commande, comme Psyche dont nous parlerons plus en détail par la suite. Ces logiciels se contentent souvent de lire un fichier d'entrée qui représente un problème et de produire une preuve ou de vérifier une preuve relative à ce problème. Cette pratique est compréhensible dans la mesure où le développement complet d'un assistant de preuve représente déjà un travail conséquent ; \textbf{le développement d'une interface utilisateur passe souvent au second plan}.\\

Les interfaces utilisateur actuelles dans le domaine des assistants de preuve se limitent souvent à des IDE \footnote{Integrated Development Environment} minimalistes qui appliquent l'idée de \textit{gestion de script} : le script de preuve est saisi ou chargé par l'utilisateur qui le fait interpréter partie par partie par l'assistant de preuve. L'avantage de ce paradigme est de permettre facilement à l'utilisateur de défaire ses actions et de voir l'état courant de la preuve.\\

Les interfaces utilisateurs pour assistants de preuve sont néanmoins incomplètes et se heurtent à beaucoup de difficultés. L'une d'entre elles est que les théorèmes et les preuves manipulées par les programmes sont des objets abstraits traduits par une syntaxe complexe. Les représenter efficacement et de manière compréhensible pour l'utilisateur est un problème délicat, auquel sont également confrontés d'autres logiciels comme les éditeurs d'équations.

\subsection{Objectifs du projet}

L'objectif de ce projet est double : d'un côté, il consiste en \textbf{l'étude des solutions qui peuvent être développées pour améliorer l'ergonomie des assistants de preuve} ; de l'autre, il consiste en \textbf{l'implémentation de certaines de ces solutions à travers le développement d'un mini-prototype}.\\

La première partie vise à identifier les points bloquants des ergonomies proposées dans les assistants de preuve actuels, pour ensuite proposer des idées de solutions à ces problèmes. C'est l'objet de la troisième grande partie de ce rapport de projet, qui constitue la synthèse de cette réflexion. Les sources de ce travail sont bien évidemment les remarques que l'on peut se faire lors de l'utilisation des logiciels -- les \textit{retours des utilisateurs}, mais également les principes généraux en matière de conception des interfaces utilisateurs.\\

La deuxième partie vise à implémenter certaines des solutions envisagées, de manière à pouvoir faire valider ces hypothèses de solution par des utilisateurs. Pour cette raison, l'implémentation proposée doit se baser sur un assistant de preuve complet et utilisable pour que le test du prototype se fasse sur des problèmes réels.\\

C'était un souhait de ma part de mener ces deux tâches en parallèle. J'ai déjà eu l'occasion de travailler dans des équipes qui appliquaient des méthodes de projet dites "agiles"\footnote{L'agilité est une philosophie de développement de produit qui s'oppose aux méthodes traditionnelles et se veut plus pragmatiques qu'elles. Le \textit{manifeste Agile} est disponible ici : \url{http://agilemanifesto.org}.}. Il est bénéfique que le prototype et les idées qu'il implémente s'influencent mutuellement à travers des \textbf{cycles de développement itératifs} et la prise en compte des retours des utilisateurs et des développeurs. Cela rend de fait les deux parties de mon travail interdépendantes et d'importance égales.

\subsection{Objets de travail}

Le projet s'appuie sur un assistant de preuve existant, que ce soit pour l'étude du sujet ou pour l'implémentation du prototype. Il s'agit de l'outil \textbf{Psyche}\footnote{\url{http://www.lix.polytechnique.fr/~lengrand/Psyche/}}.\\

Psyche est un assistant de preuve \textbf{modulaire}, dans le sens où il est construit selon une architecture dans laquelle le noyau de l'application interagit avec des modules périphériques, les plugins. Plus précisément, le noyau garantit la correction de la réponse renvoyée\footnote{Par correction, j'entends que le noyau ne peut déclarer qu'un problème est prouvable s'il ne l'est pas. Néanmoins, un plugin peut très bien ne jamais terminer sur un problème donné.} et construit l'arbre de recherche automatiquement tant qu'aucune décision ne doit être prise ; lorsque le noyau ne peut plus continuer seul, il rend la main au plugin choisi par l'utilisateur, qui prend une décision et la renvoie au noyau.\\

Cette architecture collaborative est motivée par le fait que chacun peut développer son propre plugin, basé sur une heuristique choisie, sans que cela ne présente de risque pour la correction du programme. C'est la raison pour laquelle l'outil Psyche a été choisi pour ce projet : sa modularité permet plus simplement de \textbf{greffer au logiciel un plugin interactif} qui permet de communiquer avec l'utilisateur à travers une interface.\\

Un tel plugin doté d'une interface graphique n'existe pas encore pour Psyche : c'est le développement de ce plugin qui constitue le travail de développement du prototype. Psyche étant programmé en OCaml, il paraîtrait naturel de penser à développer l'interface utilisateur du prototype dans ce même langage.\\

Pourtant, j'ai préféré faire le choix d'utiliser des \textbf{technologies issues des applications Web} -- React, Javascript, NodeJS, HTML, CSS -- pour le prototype, et ce pour plusieurs raisons :
\begin{itemize}
\item Les applications Web ont l'avantage d'être plus \textbf{portables et accessibles} pour les utilisateurs. On peut de plus imaginer que dans la perspective d'effectuer des preuves distribuées sur serveurs, une interface Web pour observer et piloter le travail de l'assistant de preuve serait plus naturelle ;
\item Une interface Web peut communiquer avec un assistant de preuve écrit dans n'importe quel langage, pourvu que ce dernier offre une API\footnote{\textit{Application Programming Interface}, en français Interface de Programmation Applicative.} suffisante, et ce sans adaptation du code de l'interface ;
\item Les technologies Web modernes s'appuient sur des \textbf{cycles de développement courts} qui leur permettent d'implémenter rapidement les évolutions en matière d'ergonomie. Des gestionnaires de paquets comme \textbf{npm}\footnote{\textit{Node Package Manager}, disponible ici : \url{https://www.npmjs.com/}} permettent d'installer facilement des librairies développées en Open Source par la communauté de développeurs Web ;
\item Il existe de nombreuses librairies qui proposent des implémentations de \textbf{règles de design} -- l'une d'entre elles étant Material Design\footnote{\textit{Material Design} a été proposé par Google. Il est notamment utilisé dans les versions récentes du système d'exploitation mobile Android et plus largement sur Internet. Les règles proposées sont expliquées ici : \url{https://material.io/guidelines/}} -- et facilitent donc la mise en place d'interfaces utilisateur cohérentes.
\end{itemize}

Un des challenges du projet est de réussir cette utilisation du logiciel Psyche, écrit en OCaml, en tant qu'API d'une interface Web écrite principalement en Javascript.